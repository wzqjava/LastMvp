package com.cj.caojun.lastmvp.test;

/**
 * Created by caojun on 2017/10/17.
 */

public class Example{               // 我来分析一下内存分配情况吧！

    public String  str= new String("good");
    //String str 时,把str引用放在栈空间，值为null , 当new String 时 ，在堆空间生成一个 good ,并且Str指向它！

    public char[]ch={'a','b','c'};
    //char[]ch 时,把ch 引用放在栈空间，在堆空间生成一个数组 a,b,c 并且ch 指向它们


    public void change(String str,char ch[]){

        // 可能这里你会误会 ，这里的str 不同于 外面的 str ,
        // 这里的意思是, String str 在栈空间 '新建' 一个str ， 其实那里已有一个 str ，就是上面那个
        // 他们两个并不一样 ，这个str 是局部变量,依赖于方法 , 只要方法结束，它就自动消亡，而外面那个还在，
        // 所以这里就是 ，把外面的 str 传进来，把值赋给 这个 str ，此时两个都是 ''good''

        // 而char [] 分析则不同  ，
        // 请先 记住 ，ch [0]，ch[1] ,ch[2] ...都是存在堆空间的 ，即是他们的地址空间，
        // 对于这种引用类型的变量（例如数组，对象）,他们其实是把传进来的值直接放在引用地址.
        // 即 ch[0] 始终只有一 个，并且指向堆空间，参数传进来也是在堆空间里面。

        str="test ok";
        // 然后执行这一步时 ， 这里面的str值就变化了 ，即变为 test ok ， 请记住此时在栈空间是有两个 str 哦
        // 外面依然是 good , 可里面的 变成 test ok , 好的 ，继续 ...

        ch[0]='g';

        // 据上面分析，很显然 ， ch[0] 始终是一个 ，并且存放和修改都是直接在堆空间， 所以这里ch[0]变成 'g'
    } // 好，这个方法终于运行结束 ， 重点来了， 到这里 谁 死掉了 , 就是这里面那个 依赖于方法存在的局部变量 str
    // 那么现在一共就只有一个 str ，并且它的值为 good ,当接下去控制台输出的时候调用 str ，
    // 你说还会调用那个死了的 str 吗， 显然 调用 还存在的 str  即是 good
}

// 其实 , 假如想看明白，你可以这样 ， 把方法里面的 str , 改为 this.str .
// 你就能够区分  : 原来他们真是 两个 str ，而使用 this （本类) 调用的才是成员变量!
// 不依赖方法 ，就是命硬 ， 死不了 ！
// 这样分析， 你懂了吗 ？